<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<title>TDR 16分類図鑑</title>
<meta name="description" content="TDRの16タイプを一覧で確認。クリックで該当タイプへスクロール。">
<style>
  body{margin:0;background:#0f1115;color:#e8ecf1;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Noto Sans JP","Hiragino Kaku Gothic ProN","Yu Gothic UI",sans-serif;line-height:1.7}
  .wrap{max-width:1080px;margin:0 auto;padding:16px}
  h1{font-size:22px;margin:8px 0 4px}
  .sub{color:#9aa4b2;font-size:13px}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:8px;margin:14px 0 10px}
  .chip{display:block;text-align:center;padding:10px 8px;border-radius:10px;background:#171a21;border:1px solid #ffffff22;color:#e8ecf1;text-decoration:none;font-weight:700}
  .chip:hover{background:#1d232f;border-color:#7dd3fc}
  .card{background:#171a21;border:1px solid #ffffff22;border-radius:12px;padding:14px;margin:12px 0}
  .code{font-family:ui-monospace,Menlo,monospace;font-weight:800}
  .sect{border-left:4px solid #22d3ee;padding-left:10px;margin-top:6px}
  .tags{display:flex;flex-wrap:wrap;gap:6px;margin-top:6px}
  .tag{font-size:12px;padding:3px 8px;border-radius:999px;background:#ffffff10;border:1px solid #ffffff20}
  .foot{color:#9aa4b2;font-size:12px;margin-top:8px}
  .toplink{
    position:fixed;right:14px;bottom:14px;
  z-index:9999;              /* ←最前面へ */
  background:#7dd3fc;color:#081019;border:none;border-radius:999px;
  padding:10px 14px;font-weight:800;cursor:pointer;
  opacity:0; pointer-events:none; transition:opacity .2s;
  }
.toplink.show{ opacity:1; pointer-events:auto; }

/*フィルターバー*/
.filterbar{
  position: sticky; top: 0; z-index: 20;
  display: flex; flex-wrap: wrap; gap: 10px; align-items: center;
  padding: 10px 12px; margin: 8px 0 12px;
  background: rgba(23,26,33,.7); border: 1px solid #ffffff22; border-radius: 10px;
  backdrop-filter: blur(6px);
}
.filterbar .row{display:flex; gap:6px; align-items:center}
.filterbar label{font-size:12px; color:#9aa4b2}
.filterbar select{
  background:#0f1115; color:#e8ecf1; border:1px solid #ffffff33;
  border-radius:8px; padding:6px 8px
}
.filterbar .ghost{
  margin-left:auto; background:transparent; color:#e8ecf1;
  border:1px solid #ffffff33; border-radius:8px; padding:6px 10px; cursor:pointer
}
.filterbar .count{font-size:12px; color:#9aa4b2}
@media (max-width:700px){ .filterbar{gap:8px} .filterbar .ghost{order:5; margin-left:0} }

  
</style>
</head>
<body>
<!-- 固定フィルタバー -->
<div id="filterBar" class="filterbar">
  <div class="row">
    <label>I/E</label>
    <select data-axis="ie">
      <option value="M">M（両方）</option>
      <option value="I">I</option>
      <option value="E">E</option>
    </select>
  </div>
  <div class="row">
    <label>T（温度）</label>
    <select data-axis="t">
      <option value="M">M（中庸）</option>
      <option value="C">C（低温）</option>
      <option value="H">H（高温）</option>
    </select>
  </div>
  <div class="row">
    <label>D（深さ）</label>
    <select data-axis="d">
      <option value="M">M（中庸）</option>
      <option value="S">S（浅）</option>
      <option value="D">D（深）</option>
    </select>
  </div>
  <div class="row">
    <label>R（硬さ）</label>
    <select data-axis="r">
      <option value="M">M（中庸）</option>
      <option value="F">F（柔）</option>
      <option value="R">R（硬）</option>
    </select>
  </div>

  <button id="resetFilter" class="ghost">リセット</button>
  <div class="count"><span id="hitCount">16</span> / 16 件</div>
</div>

  
<div class="wrap">
  <h1>TDR 16分類図鑑</h1>
  <div class="sub">一覧からタイプを選ぶと、ページ内の該当セクションへスクロールします。</div>

  <nav id="grid" class="grid"></nav>

  <main id="details"></main>

  <div class="foot">データはブラウザ内で読み込みます（<code>../data/types.json</code>）。</div>
</div>

<button type="button" id="toTop" class="toplink">▲ TOP</button>

<script>
(async function(){
  const MSG = (txt)=>{ 
    document.getElementById("grid").innerHTML = `<div class="sub">${txt}</div>`; 
  };

  try {
    // ここは types.json の実位置に合わせて
    const url = "../data/types.json";
    const res = await fetch(url, {cache:"no-store"});
    if(!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
    const raw = await res.json();

    // 配列でもオブジェクトでも受け取れるように正規化
    let types;
    if (Array.isArray(raw)) {
      types = raw;
    } else if (Array.isArray(raw.items)) {
      types = raw.items;
    } else {
      // { "E-HDR": {...}, ... } 形式なら値を配列化
      types = Object.values(raw);
    }

    if (!Array.isArray(types) || types.length === 0) {
      MSG("types.json は読み込めましたが、配列が空でした。構造を確認してください。");
      console.warn("raw:", raw);
      return;
    }

    // ソート（code を想定・なければ name）
    types.sort((a,b)=>(a.code||a.name).localeCompare(b.code||b.name));

    // 一覧（チップ）
    const grid = document.getElementById("grid");
    grid.innerHTML = types.map(t => 
      `<a class="chip" href="#${t.code||t.id}">${t.code||t.id}</a>`
    ).join("");

   // 画像パス補正関数
function resolveImg(p){
  if (!p) return "";
  if (/^https?:\/\//.test(p)) return p;            // 外部URLはそのまま
  if (p.startsWith("/")) return p;                 // 絶対パス指定もそのまま
  // atlas 下にいるときは1階層戻す
  return (location.pathname.includes("/atlas/") ? "../" : "") + p;
}

// 詳細
const details = document.getElementById("details");
details.innerHTML = types.map(t => {
  const code = t.code || t.id || "UNKNOWN";
  const name = t.name || "名称未設定";
  const desc = t.desc || t.description || "";
  const longdesc = t.longdesc || "";
  const adj  = t.adjust || {};
  const tags = t.tags ? t.tags.map(x=>`<span class="tag">${x}</span>`).join("") : "";
  const img  = resolveImg(t.img || "");

  return `
    <section id="${code}" class="card">
      <div class="sect">
        <div style="font-size:18px;font-weight:800">
          ${name} <span class="code">(${code})</span>
        </div>
        ${img ? `<img src="${img}" alt="${name}" style="max-height:300px;margin-top:6px;" onerror="this.remove()">` : ""}
        <div class="tags">${tags}</div>
      </div>
      <p style="margin-top:8px">${desc}</p>
      ${longdesc ? `<p style="margin-top:8px;font-size:14px;line-height:1.6">${longdesc}</p>` : ""}
      <div style="font-weight:700;margin-top:8px">逆方向調整</div>
      <ul style="margin:6px 0 0 18px">
        <li>内/外 （I/E）：${adj["I/E"] ?? "-"}</li>
        <li>温度T（H/C）：${adj["H/C"] ?? "-"}</li>
        <li>深さD（D/S）：${adj["D/S"] ?? "-"}</li>
        <li>硬さR（R/F）：${adj["R/F"] ?? "-"}</li>
      </ul>
    </section>
  `;
}).join("");
    
    // ハッシュ着地があればスクロール
    if (location.hash) {
      const el = document.querySelector(location.hash);
      el && el.scrollIntoView({behavior:"smooth", block:"start"});
    }

    // 内部リンクもスムースに
    document.querySelectorAll('a[href^="#"]').forEach(a=>{
      a.addEventListener("click", e=>{
        const id = a.getAttribute("href");
        const el = document.querySelector(id);
        if(el){
          e.preventDefault();
          history.replaceState(null,"",id);
          el.scrollIntoView({behavior:"smooth", block:"start"});
        }
      });
    });

    console.log(`Loaded types: ${types.length}`, types);
  } catch (err) {
    MSG(`読み込み失敗：${String(err)}`);
    console.error(err);
  }
})();

  // …既存の即時関数の下でもOK
  (function(){
    const btn = document.getElementById('toTop');
    // どっちがスクロール親でも効くように保険をかける
    function toTopSmooth(){
      try{ window.scrollTo({top:0, behavior:'smooth'}); }catch(e){}
      try{ document.documentElement.scrollTo({top:0, behavior:'smooth'}); }catch(e){}
      try{ document.body.scrollTo({top:0, behavior:'smooth'}); }catch(e){}
    }
    btn.addEventListener('click', toTopSmooth);

    // スクロール量で表示/非表示
    function onScroll(){
      const y = window.scrollY || document.documentElement.scrollTop || document.body.scrollTop || 0;
      if(y > 400) btn.classList.add('show'); else btn.classList.remove('show');
    }
    window.addEventListener('scroll', onScroll, {passive:true});
    onScroll(); // 初期評価
  })();
  
// 直前に追加：コードを I/E-TDR に分解
function splitLetters(code){
  const m = String(code||"").toUpperCase().match(/^([IE])\-([HC])([DS])([RF])$/);
  if(!m) return {ie:"M", t:"M", d:"M", r:"M"};
  return {ie:m[1], t:m[2], d:m[3], r:m[4]};
  // 既存の types（types.json 読み込み済み）を使う想定。
  
// まずカード描画を関数化（今ある map… をこの関数の中へ移動）
function renderDetails(list){
  const details = document.getElementById("details");
  details.innerHTML = list.map(t => {
    const code = t.code || t.id || "UNKNOWN";
    const name = t.name || "名称未設定";
    const desc = t.desc || t.description || "";
    const longdesc = t.longdesc || "";
    const adj  = t.adjust || {};
    const tags = t.tags ? t.tags.map(x=>`<span class="tag">${x}</span>`).join("") : "";
    const img  = t.img || "";
    const L = splitLetters(code);  // ← ここで分解
    
    return `
     <section id="${code}" class="card type"
      data-code="${code}"
      data-ie="${L.ie}" data-t="${L.t}" data-d="${L.d}" data-r="${L.r}">
      <div class="sect">
        <div style="font-size:18px;font-weight:800">${name} <span class="code">(${code})</span></div>
        ${img ? `<img src="${img}" alt="${name}" style="max-width:160px;max-height:220px;height:auto;margin-top:6px;border-radius:8px;box-shadow:0 4px 14px #00000040">` : ""}
        <div class="tags">${tags}</div>
      </div>
      <p style="margin-top:8px">${desc}</p>
      ${longdesc ? `<p style="margin-top:8px;font-size:14px;line-height:1.8">${longdesc}</p>` : ""}
      <div style="font-weight:700;margin-top:8px">逆方向調整</div>
      <ul style="margin:6px 0 0 18px">
        <li>I/E：${adj["I/E"] ?? "-"}</li>
        <li>T（H/C）：${adj["H/C"] ?? "-"}</li>
        <li>D（D/S）：${adj["D/S"] ?? "-"}</li>
        <li>R（R/F）：${adj["R/F"] ?? "-"}</li>
      </ul>
    </section>
  `;
 }).join("");
}

// --- フィルタロジック ---
const state = { ie:'M', t:'M', d:'M', r:'M' }; // デフォルト M-MMM

function matchCode(code, s){
  // code: "E-HDR" のような形式
  const [IE, rest] = String(code).split("-");
  const T = rest?.[0], D = rest?.[1], R = rest?.[2];
  const ok = (sel, v) => sel === 'M' || sel === v; // M は両方OK
  return ok(s.ie, IE) && ok(s.t, T) && ok(s.d, D) && ok(s.r, R);
}

function setupFilter(types){
  const bar = document.getElementById('filterBar');
  const selects = bar.querySelectorAll('select[data-axis]');
  const hit = document.getElementById('hitCount');

  const apply = () => {
    const filtered = types.filter(t => matchCode(t.code, state));
    renderDetails(filtered);
    hit.textContent = filtered.length;
  };

  selects.forEach(sel=>{
    const ax = sel.dataset.axis;
    sel.value = state[ax];               // 初期 M
    sel.addEventListener('change', e=>{
      state[ax] = e.target.value;
      apply();
    });
  });
  bar.querySelector('#resetFilter').addEventListener('click', ()=>{
    state.ie = state.t = state.d = state.r = 'M';
    selects.forEach(s => s.value = 'M');
    apply();
  });

  apply(); // 初回描画（= M-MMM ですべて表示）
}

// ここは types を取得した後に呼ぶ（既存のロード箇所で差し替え）
/*
fetch('data/types.json').then(r=>r.json()).then(types=>{
  setupFilter(types);    // ←これだけ追加
});
*/

// カードの表示/非表示を切り替える
function applyFilter(){
  const ie = (document.getElementById('fIE')?.value || 'M').toUpperCase();
  const t  = (document.getElementById('fT') ?.value || 'M').toUpperCase();
  const d  = (document.getElementById('fD') ?.value || 'M').toUpperCase();
  const r  = (document.getElementById('fR') ?.value || 'M').toUpperCase();

  let shown = 0;
  document.querySelectorAll('.card.type').forEach(el=>{
    const ok =
      (ie==='M' || el.dataset.ie === ie) &&
      (t ==='M' || el.dataset.t  === t ) &&
      (d ==='M' || el.dataset.d  === d ) &&
      (r ==='M' || el.dataset.r  === r );

    el.style.display = ok ? '' : 'none';
    if(ok) shown++;
  });

  const label = document.getElementById('fCount');
  if(label) label.textContent = `${shown}/16`;
}

// イベントを接続（DOM生成の後で！）
['fIE','fT','fD','fR'].forEach(id=>{
  const el = document.getElementById(id);
  if(el) el.addEventListener('change', applyFilter);
});
const resetBtn = document.getElementById('fReset');
if(resetBtn){
  resetBtn.addEventListener('click', ()=>{
    ['fIE','fT','fD','fR'].forEach(id=>{
      const el = document.getElementById(id);
      if(el) el.value = 'M';
    });
    applyFilter();
  });
}

// 初期表示（デフォルト M-MMM）
applyFilter();
  
</script>

</body>
</html>
